# 2026-01-19 セッション記録

## セッション概要

| 項目 | 内容 |
|------|------|
| 目的 | NestJS学習（DTOバリデーション詳解） |
| 作業特性 | 学習資料作成 / 調査分析 |

## 完了事項

### 1. DTOバリデーション学習資料作成

`docs/learning/dto-validation.md`を新規作成:

| セクション | 内容 |
|-----------|------|
| デコレータの共通オプション | ValidationOptions（message, each, groups）、ValidationArguments |
| 基本デコレータ詳細 | 文字列系、数値系、日付系（応用編含む）、列挙型・配列 |
| 型変換 | @Type()デコレータ、暗黙的型変換、カスタム変換 |
| 条件付きバリデーション | @ValidateIf()による条件分岐 |
| ネストオブジェクト | @ValidateNested() + @Type()の組み合わせ |
| カスタムバリデータ | registerDecorator()、@ValidatorConstraint、NestJS DI統合 |
| クラスレベルバリデーション | 複数フィールドの整合性チェック |
| バリデーショングループ | 同じDTOを異なるコンテキストで使い分け |
| 実プロジェクト実装例 | RegisterDto, CreateTaskDto, TaskQueryDto, ChangePasswordDto |

### 2. 学習資料READMEの更新

`docs/learning/README.md`に以下を追加:
- `nestjs-controller.md`（前回作成）
- `dto-validation.md`（今回作成）

### 3. プロジェクト状況の更新

`docs/sessions/project-status.md`を更新:
- 直近の完了事項に今回の成果を追加
- 次回セッション優先事項を更新（次回: Filter / Interceptor）

## 技術的知見・学び

### ValidationOptionsの重要性

- 全デコレータ共通で`message`, `each`, `groups`等のオプションを持つ
- 動的メッセージでは`ValidationArguments`を使って詳細情報にアクセス可能
- `each: true`で配列の各要素に対してバリデーションを実行

### 条件付きバリデーション

- `@ValidateIf()`で他のフィールドの値に応じたバリデーション制御が可能
- 例: 支払い方法がクレジットカードの場合のみカード番号を検証

### カスタムバリデータの2つの方法

| 方法 | 特徴 | 用途 |
|-----|------|------|
| `registerDecorator()` | 関数ベース、シンプル | 単純なカスタムルール |
| `@ValidatorConstraint` | クラスベース、DI対応 | Repositoryへのアクセスが必要な場合 |

### クラスレベルバリデーション

- 複数フィールドの整合性チェック（例: 開始日 ≤ 終了日）
- `@Validate()`をクラスに直接適用

### バリデーショングループ vs 別DTO

- グループを使うより、Create用とUpdate用で別のDTOを作成する方が明確
- グループは複雑になりがちなので、シンプルな設計を優先

### 日付バリデーションの注意点

- `@IsISO8601()`は文字列形式を検証するだけで、`Date`への変換は行わない
- `@MinDate()`/`@MaxDate()`は`Date`オブジェクトを期待するため、`@Type(() => Date)`との併用が必須
- タイムゾーンオフセット付きISO8601（例: `+09:00`）は`@Type(() => Date)`で自動的にUTCに変換される
- `@MinDate(new Date())`はサーバー起動時の時刻で固定されるため、動的な検証にはカスタムバリデータが必要

### ISO8601とタイムゾーン

- JSONには日付型がないため、日付は文字列で表現する必要があり、ISO8601が事実上の標準
- ISO8601はタイムゾーンオフセット付き（`+09:00`）も有効な形式
- 国際対応APIではオフセット付きISO8601を受け取り、サーバー側でUTCに変換して保存するパターンが推奨

### null/undefinedの設計判断

- JavaScriptには「値がない」を表す`undefined`と`null`の2種類が存在
- `undefined` = プロパティが存在しない（未送信）
- `null` = 意図的に「空」を示す
- `@IsOptional()`は`undefined`のみ許可し、`null`は許可しない設計
- 本プロジェクトでは「nullを使わない」ポリシーを採用（`.claude/rules/null-undefined-policy.md`）

### バリデーショングループの起源

- class-validatorの`groups`オプションはJava Bean Validation（JSR-303/JSR-380）が起源
- Angular ReactiveFormsとは直接の継承関係はないが、同様の課題を解決する思想

## 作成・変更したファイル

| ファイル | 操作 |
|---------|------|
| `docs/learning/dto-validation.md` | 新規作成 |
| `docs/learning/README.md` | 更新（新資料の追加） |
| `docs/sessions/project-status.md` | 更新（完了事項・次回優先事項） |
| `docs/sessions/daily/2026-01-19.md` | 新規作成 |
| `.claude/rules/null-undefined-policy.md` | 新規作成（null/undefinedポリシー） |

## 次回への申し送り

### 次回学習トピック

**Filter / Interceptor**（`filter-interceptor.md`として作成予定）
- ExceptionFilter（エラーハンドリング）
- Interceptor（リクエスト/レスポンス変換）
- リクエストライフサイクル全体像
- 実プロジェクトでの実装例

### 学習計画の更新

| # | トピック | 状況 |
|---|---------|------|
| 1 | ~~デコレータの仕組み~~ | ✅ 完了（nestjs-controller.md） |
| 2 | ~~カスタムデコレータ~~ | ✅ 完了（同上） |
| 3 | ~~DTOのバリデーション~~ | ✅ 完了（dto-validation.md） |
| 4 | Filter / Interceptor | 📝 次回 |
| 5 | Guards | 未着手 |
| 6 | TypeORMエンティティ | 未着手 |
| 7 | サービス間通信 | 未着手 |

### 既知の問題

- ralph-wiggum Windows非対応（Issue #1、上流修正待ち）
- WSL環境移行が必要（Issue #4）
